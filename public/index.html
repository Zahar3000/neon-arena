<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Arena - Multiplayer Shooter</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@400;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            background: #0B0F19;
            overflow: hidden;
            font-family: 'Rajdhani', sans-serif;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            background: #0B0F19;
            cursor: crosshair;
        }

        /* UI Overlay */
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Health Bar */
        #healthContainer {
            position: absolute;
            bottom: 30px;
            left: 30px;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .healthSegment {
            width: 35px;
            height: 12px;
            background: linear-gradient(180deg, rgba(0, 240, 255, 0.3), rgba(0, 240, 255, 0.1));
            border: 2px solid #00F0FF;
            border-radius: 3px;
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
            transition: all 0.3s ease;
        }

        .healthSegment.lost {
            background: rgba(255, 0, 60, 0.2);
            border-color: rgba(255, 0, 60, 0.5);
            box-shadow: none;
        }

        /* Leaderboard */
        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(11, 15, 25, 0.9);
            border: 2px solid rgba(0, 240, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            min-width: 200px;
        }

        #leaderboard h3 {
            color: #00F0FF;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
        }

        .leaderboardEntry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
        }

        .leaderboardEntry:last-child {
            border-bottom: none;
        }

        .leaderboardEntry.self {
            color: #00F0FF;
            font-weight: 700;
        }

        .leaderboardName {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .leaderboardColor {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .leaderboardScore {
            font-family: 'Orbitron', sans-serif;
        }

        /* Chat */
        #chatContainer {
            position: absolute;
            bottom: 60px;
            left: 20px;
            width: 300px;
            max-height: 200px;
            overflow-y: auto;
            pointer-events: auto;
        }

        .chatMessage {
            background: rgba(11, 15, 25, 0.8);
            border-left: 3px solid #00F0FF;
            padding: 8px 12px;
            margin-bottom: 5px;
            font-size: 13px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .chatNickname {
            color: #00F0FF;
            font-weight: 700;
            margin-right: 5px;
        }

        #chatInput {
            width: 100%;
            background: rgba(11, 15, 25, 0.9);
            border: 2px solid rgba(0, 240, 255, 0.3);
            border-radius: 5px;
            padding: 10px 15px;
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            outline: none;
            pointer-events: auto;
        }

        #chatInput:focus {
            border-color: #00F0FF;
        }

        /* Room Info */
        #roomInfo {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
        }

        #roomInfo span {
            color: #00F0FF;
            font-family: 'Orbitron', sans-serif;
        }

        /* ============================================
           LOBBY SCREENS
           ============================================ */

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(11, 15, 25, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: auto;
        }

        .overlay.hidden {
            display: none !important;
        }

        /* Main Menu */
        #mainMenu {
            background: radial-gradient(ellipse at center, rgba(0, 240, 255, 0.05) 0%, transparent 70%);
        }

        #gameLogo {
            font-family: 'Orbitron', sans-serif;
            font-size: 56px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 30px rgba(0, 240, 255, 0.8), 0 0 60px rgba(0, 240, 255, 0.4);
            margin-bottom: 10px;
            letter-spacing: 6px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 30px rgba(0, 240, 255, 0.8), 0 0 60px rgba(0, 240, 255, 0.4); }
            to { text-shadow: 0 0 40px rgba(0, 240, 255, 1), 0 0 80px rgba(0, 240, 255, 0.6); }
        }

        #gameSubtitle {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 50px;
            letter-spacing: 8px;
            text-transform: uppercase;
        }

        .menuForm {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(0, 240, 255, 0.2);
            border-radius: 15px;
            padding: 40px;
            width: 100%;
            max-width: 400px;
        }

        .formGroup {
            margin-bottom: 20px;
        }

        .formGroup label {
            display: block;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
        }

        .formGroup input {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(0, 240, 255, 0.3);
            border-radius: 8px;
            padding: 15px 20px;
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            font-size: 18px;
            outline: none;
            transition: all 0.3s;
        }

        .formGroup input:focus {
            border-color: #00F0FF;
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.3);
        }

        .btn {
            width: 100%;
            padding: 15px 30px;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            font-weight: 700;
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .btnPrimary {
            background: linear-gradient(135deg, #00F0FF, #0099CC);
            box-shadow: 0 5px 25px rgba(0, 240, 255, 0.4);
        }

        .btnPrimary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 35px rgba(0, 240, 255, 0.6);
        }

        .btnSecondary {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .btnSecondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btnStart {
            background: linear-gradient(135deg, #00FF88, #00CC66);
            box-shadow: 0 5px 25px rgba(0, 255, 136, 0.4);
        }

        .btnStart:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 35px rgba(0, 255, 136, 0.6);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .divider {
            display: flex;
            align-items: center;
            margin: 20px 0;
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .divider::before,
        .divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
        }

        .divider span {
            padding: 0 15px;
        }

        /* Waiting Room */
        #waitingRoom .menuForm {
            max-width: 500px;
        }

        #roomTitle {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            color: #00F0FF;
            text-align: center;
            margin-bottom: 20px;
        }

        #roomCode {
            background: rgba(0, 240, 255, 0.1);
            padding: 5px 15px;
            border-radius: 5px;
            font-family: 'Orbitron', sans-serif;
        }

        #playerList {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .playerEntry {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .playerEntry:last-child {
            margin-bottom: 0;
        }

        .playerInfo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .playerColor {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        .playerName {
            font-weight: 700;
        }

        .playerStatus {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
        }

        .playerStatus.host::after {
            content: ' ★';
            color: #FFD700;
        }

        .waitingDots {
            display: inline-block;
            width: 20px;
            text-align: left;
        }

        /* Game Over */
        #gameOverScreen .menuForm {
            max-width: 450px;
        }

        #winnerAnnouncement {
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            font-weight: 900;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 20px currentColor;
        }

        #finalLeaderboard {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        /* Connection Status */
        #connectionStatus {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 200;
            transition: all 0.3s;
        }

        #connectionStatus.connected {
            background: rgba(0, 255, 136, 0.2);
            color: #00FF88;
            border: 2px solid #00FF88;
        }

        #connectionStatus.disconnected {
            background: rgba(255, 0, 60, 0.2);
            color: #FF003C;
            border: 2px solid #FF003C;
        }

        #connectionStatus.connecting {
            background: rgba(255, 165, 0, 0.2);
            color: #FFA500;
            border: 2px solid #FFA500;
        }

        /* Error/Success Messages */
        .message {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .messageError {
            background: rgba(255, 0, 60, 0.2);
            color: #FF003C;
            border: 1px solid rgba(255, 0, 60, 0.5);
        }

        .messageSuccess {
            background: rgba(0, 255, 136, 0.2);
            color: #00FF88;
            border: 1px solid rgba(0, 255, 136, 0.5);
        }

        /* Loading Spinner */
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top-color: #00F0FF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Controls Info */
        #controlsHint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            text-align: center;
        }

        #controlsHint span {
            color: #00F0FF;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="connectionStatus" class="connecting">Подключение...</div>

    <!-- MAIN MENU -->
    <div id="mainMenu" class="overlay">
        <div id="gameLogo">NEON ARENA</div>
        <div id="gameSubtitle">Multiplayer Shooter</div>

        <div class="menuForm">
            <div id="menuMessage" class="message" style="display: none;"></div>

            <div class="formGroup">
                <label>Ваш никнейм</label>
                <input type="text" id="nicknameInput" placeholder="Введите никнейм..." maxlength="20" autocomplete="off">
            </div>

            <button class="btn btnPrimary" id="createRoomBtn">
                Создать комнату
            </button>

            <div class="divider"><span>или</span></div>

            <div class="formGroup">
                <label>Код комнаты</label>
                <input type="text" id="roomCodeInput" placeholder="Введите код комнаты..." maxlength="6" autocomplete="off">
            </div>

            <button class="btn btnSecondary" id="joinRoomBtn">
                Присоединиться
            </button>
        </div>

        <div id="controlsHint">
            <span>WASD</span> движение | <span>МЫШЬ</span> прицел | <span>ЛКМ</span> стрельба
        </div>
    </div>

    <!-- WAITING ROOM -->
    <div id="waitingRoom" class="overlay hidden">
        <div class="menuForm">
            <div id="roomTitle">
                Комната: <span id="roomCode">XXXXXX</span>
            </div>

            <div id="playerList">
                <!-- Players will be added here -->
            </div>

            <div id="waitingMessage" style="text-align: center; color: rgba(255,255,255,0.5); margin-bottom: 20px;">
                Ожидание игроков<span class="waitingDots">...</span>
            </div>

            <button class="btn btnStart" id="startGameBtn">
                Начать игру
            </button>

            <button class="btn btnSecondary" id="leaveRoomBtn">
                Покинуть комнату
            </button>
        </div>
    </div>

    <!-- GAME OVER -->
    <div id="gameOverScreen" class="overlay hidden">
        <div class="menuForm">
            <div id="winnerAnnouncement" style="color: #00F0FF;">
                ИГРА ОКОНЧЕНА
            </div>

            <div id="finalLeaderboard">
                <!-- Final scores will be shown here -->
            </div>

            <button class="btn btnSecondary" id="backToMenuBtn">
                В главное меню
            </button>
        </div>
    </div>

    <!-- IN-GAME UI -->
    <div id="ui" class="hidden">
        <div id="roomInfo">
            Комната: <span id="currentRoomCode">XXXXXX</span>
        </div>

        <div id="leaderboard">
            <h3>Таблица очков</h3>
            <div id="leaderboardList">
                <!-- Scores will be updated here -->
            </div>
        </div>

        <div id="healthContainer">
            <!-- Health segments will be added dynamically -->
        </div>

        <div id="chatContainer">
            <div id="chatMessages"></div>
            <input type="text" id="chatInput" placeholder="Сообщение..." maxlength="200">
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // ============================================
        // NEON ARENA - Multiplayer Client
        // ============================================

        class GameClient {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.socket = io();

                // Game state
                this.state = {
                    players: [],
                    bullets: [],
                    enemies: [],
                    roomId: null,
                    playerId: null,
                    isHost: false,
                    gameStarted: false
                };

                // Local player
                this.localPlayer = null;
                this.input = {
                    up: false,
                    down: false,
                    left: false,
                    right: false,
                    angle: 0,
                    shooting: false
                };

                // Camera
                this.camera = { x: 0, y: 0 };

                // Canvas size
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                // Initialize UI
                this.initUI();

                // Connect to server
                this.connectToServer();

                // Start render loop
                this.lastRenderTime = 0;
                requestAnimationFrame((time) => this.renderLoop(time));
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            initUI() {
                // Menu buttons
                document.getElementById('createRoomBtn').addEventListener('click', () => this.createRoom());
                document.getElementById('joinRoomBtn').addEventListener('click', () => this.joinRoom());
                document.getElementById('startGameBtn').addEventListener('click', () => this.startGame());
                document.getElementById('leaveRoomBtn').addEventListener('click', () => this.leaveRoom());
                document.getElementById('backToMenuBtn').addEventListener('click', () => this.backToMenu());

                // Keyboard controls
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));

                // Mouse controls
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        this.input.shooting = true;
                    }
                });
                document.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        this.input.shooting = false;
                    }
                });

                // Chat
                document.getElementById('chatInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && e.target.value.trim()) {
                        this.socket.emit('chat', e.target.value.trim());
                        e.target.value = '';
                    }
                });
            }

            connectToServer() {
                const statusEl = document.getElementById('connectionStatus');

                this.socket.on('connect', () => {
                    statusEl.textContent = 'Подключено';
                    statusEl.className = 'connected';
                    console.log('Connected to server');
                });

                this.socket.on('disconnect', () => {
                    statusEl.textContent = 'Отключено';
                    statusEl.className = 'disconnected';
                    this.state.gameStarted = false;
                    this.showScreen('mainMenu');
                    this.showMessage('menuMessage', 'Соединение с сервером потеряно', 'error');
                });

                this.socket.on('connect_error', () => {
                    statusEl.textContent = 'Ошибка подключения';
                    statusEl.className = 'disconnected';
                });

                // Game events
                this.socket.on('roomJoined', (data) => {
                    this.state.roomId = data.roomId;
                    this.state.playerId = data.playerId;
                    this.state.isHost = data.isHost;
                    this.state.players = data.state.players;
                    this.state.gameStarted = data.state.state === 'playing';

                    this.updatePlayerList();
                    this.updateHealthUI();
                    this.showScreen('waitingRoom');
                    document.getElementById('roomCode').textContent = data.roomId;
                    document.getElementById('currentRoomCode').textContent = data.roomId;
                    document.getElementById('startGameBtn').disabled = !data.isHost || this.state.players.length < 1;
                    console.log(`Joined room ${data.roomId}`);
                });

                this.socket.on('playerJoined', (data) => {
                    this.state.players.push(data.player);
                    this.updatePlayerList();
                    document.getElementById('startGameBtn').disabled = !this.state.isHost || this.state.players.length < 1;
                    this.addChatMessage('Система', `${data.player.nickname} присоединился к игре`);
                });

                this.socket.on('playerLeft', (data) => {
                    const player = this.state.players.find(p => p.id === data.playerId);
                    if (player) {
                        this.addChatMessage('Система', `${player.nickname} покинул игру`);
                    }
                    this.state.players = this.state.players.filter(p => p.id !== data.playerId);
                    this.updatePlayerList();
                    document.getElementById('startGameBtn').disabled = !this.state.isHost || this.state.players.length < 1;
                });

                this.socket.on('hostChanged', (data) => {
                    this.state.isHost = data.hostId === this.state.playerId;
                    this.updatePlayerList();
                    document.getElementById('startGameBtn').disabled = !this.state.isHost;
                });

                this.socket.on('gameStarted', (state) => {
                    this.state.gameStarted = true;
                    this.state.players = state.players;
                    this.state.bullets = state.bullets;
                    this.state.enemies = state.enemies;
                    this.showScreen('inGame');
                    this.addChatMessage('Система', 'Игра началась!');

                    // Find local player
                    this.localPlayer = this.state.players.find(p => p.id === this.state.playerId);
                });

                this.socket.on('gameUpdate', (state) => {
                    this.state.players = state.players;
                    this.state.bullets = state.bullets;
                    this.state.enemies = state.enemies;
                    this.localPlayer = this.state.players.find(p => p.id === this.state.playerId);
                    this.updateLeaderboard();
                    this.updateHealthUI();
                });

                this.socket.on('chatMessage', (data) => {
                    this.addChatMessage(data.nickname, data.message);
                });

                this.socket.on('error', (data) => {
                    this.showMessage('menuMessage', data.message, 'error');
                });
            }

            createRoom() {
                const nickname = document.getElementById('nicknameInput').value.trim();
                if (!nickname) {
                    this.showMessage('menuMessage', 'Введите никнейм!', 'error');
                    return;
                }
                this.socket.emit('joinRoom', { roomId: null, nickname });
            }

            joinRoom() {
                const nickname = document.getElementById('nicknameInput').value.trim();
                const roomId = document.getElementById('roomCodeInput').value.trim().toUpperCase();

                if (!nickname) {
                    this.showMessage('menuMessage', 'Введите никнейм!', 'error');
                    return;
                }
                if (!roomId) {
                    this.showMessage('menuMessage', 'Введите код комнаты!', 'error');
                    return;
                }

                this.socket.emit('joinRoom', { roomId, nickname });
            }

            startGame() {
                this.socket.emit('startGame');
            }

            leaveRoom() {
                this.socket.disconnect();
                this.socket.connect();
                this.showScreen('mainMenu');
                this.state.roomId = null;
                this.state.players = [];
                this.state.bullets = [];
                this.state.enemies = [];
            }

            backToMenu() {
                this.showScreen('mainMenu');
                this.state.gameStarted = false;
                this.state.players = [];
                this.state.bullets = [];
                this.state.enemies = [];
            }

            showScreen(screenId) {
                document.querySelectorAll('.overlay').forEach(el => el.classList.add('hidden'));
                document.getElementById('ui').classList.add('hidden');

                if (screenId === 'inGame') {
                    document.getElementById('ui').classList.remove('hidden');
                } else {
                    const screen = document.getElementById(screenId);
                    if (screen) screen.classList.remove('hidden');
                }
            }

            showMessage(containerId, text, type) {
                const container = document.getElementById(containerId);
                container.textContent = text;
                container.className = `message message${type.charAt(0).toUpperCase() + type.slice(1)}`;
                container.style.display = 'block';
                setTimeout(() => container.style.display = 'none', 3000);
            }

            updatePlayerList() {
                const list = document.getElementById('playerList');
                list.innerHTML = '';

                this.state.players.forEach(player => {
                    const div = document.createElement('div');
                    div.className = 'playerEntry';
                    div.innerHTML = `
                        <div class="playerInfo">
                            <div class="playerColor" style="background: ${player.color}"></div>
                            <span class="playerName">${player.nickname}</span>
                        </div>
                        <span class="playerStatus ${player.id === this.state.hostId ? 'host' : ''}">
                            ${player.id === this.state.hostId ? 'Организатор' : 'Готов'}
                        </span>
                    `;
                    list.appendChild(div);
                });
            }

            updateLeaderboard() {
                const list = document.getElementById('leaderboardList');
                const sorted = [...this.state.players].sort((a, b) => b.score - a.score);

                list.innerHTML = sorted.map((p, i) => `
                    <div class="leaderboardEntry ${p.id === this.state.playerId ? 'self' : ''}">
                        <div class="leaderboardName">
                            <div class="leaderboardColor" style="background: ${p.color}"></div>
                            <span>${i + 1}. ${p.nickname}</span>
                        </div>
                        <span class="leaderboardScore">${p.score}</span>
                    </div>
                `).join('');
            }

            updateHealthUI() {
                const container = document.getElementById('healthContainer');
                if (!this.localPlayer) {
                    container.innerHTML = '';
                    return;
                }

                const maxSegments = 10;
                const healthSegments = Math.ceil(this.localPlayer.health / (MAX_HEALTH / maxSegments));
                container.innerHTML = '';

                for (let i = 0; i < maxSegments; i++) {
                    const segment = document.createElement('div');
                    segment.className = 'healthSegment' + (i >= healthSegments ? ' lost' : '');
                    container.appendChild(segment);
                }
            }

            addChatMessage(nickname, message) {
                const container = document.getElementById('chatMessages');
                const div = document.createElement('div');
                div.className = 'chatMessage';
                div.innerHTML = `<span class="chatNickname">${nickname}:</span> ${this.escapeHtml(message)}`;
                container.appendChild(div);
                container.scrollTop = container.scrollHeight;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            handleKeyDown(e) {
                if (document.getElementById('chatInput') === document.activeElement) return;

                switch(e.code) {
                    case 'KeyW': case 'ArrowUp': this.input.up = true; break;
                    case 'KeyS': case 'ArrowDown': this.input.down = true; break;
                    case 'KeyA': case 'ArrowLeft': this.input.left = true; break;
                    case 'KeyD': case 'ArrowRight': this.input.right = true; break;
                }
                this.sendInput();
            }

            handleKeyUp(e) {
                switch(e.code) {
                    case 'KeyW': case 'ArrowUp': this.input.up = false; break;
                    case 'KeyS': case 'ArrowDown': this.input.down = false; break;
                    case 'KeyA': case 'ArrowLeft': this.input.left = false; break;
                    case 'KeyD': case 'ArrowRight': this.input.right = false; break;
                }
                this.sendInput();
            }

            handleMouseMove(e) {
                if (this.localPlayer) {
                    this.input.angle = Math.atan2(e.clientY - this.canvas.height / 2, e.clientX - this.canvas.width / 2);
                    this.sendInput();
                }
            }

            sendInput() {
                this.socket.emit('input', this.input);
            }

            // ============================================
            // RENDER LOOP
            // ============================================

            renderLoop(currentTime) {
                requestAnimationFrame((time) => this.renderLoop(time));

                // Clear canvas
                this.ctx.fillStyle = '#0B0F19';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (!this.state.gameStarted || !this.localPlayer) {
                    // Just draw background pattern
                    this.drawBackground();
                    return;
                }

                // Update camera to follow player
                this.camera.x = this.localPlayer.x - this.canvas.width / 2;
                this.camera.y = this.localPlayer.y - this.canvas.height / 2;

                // Clamp camera
                this.camera.x = Math.max(0, Math.min(MAP_WIDTH - this.canvas.width, this.camera.x));
                this.camera.y = Math.max(0, Math.min(MAP_HEIGHT - this.canvas.height, this.camera.y));

                this.ctx.save();
                this.ctx.translate(-this.camera.x, -this.camera.y);

                // Draw game
                this.drawBackground();
                this.drawGrid();
                this.drawEnemies();
                this.drawBullets();
                this.drawPlayers();
                this.drawBoundaries();

                this.ctx.restore();
            }

            drawBackground() {
                // Dark gradient background
                const gradient = this.ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, 0,
                    this.canvas.width / 2, this.canvas.height / 2, this.canvas.width
                );
                gradient.addColorStop(0, '#0B0F19');
                gradient.addColorStop(1, '#05080F');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            drawGrid() {
                this.ctx.strokeStyle = 'rgba(0, 240, 255, 0.05)';
                this.ctx.lineWidth = 1;

                const gridSize = 50;
                const startX = Math.floor(this.camera.x / gridSize) * gridSize;
                const startY = Math.floor(this.camera.y / gridSize) * gridSize;

                for (let x = startX; x < startX + this.canvas.width + gridSize; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, Math.max(0, this.camera.y));
                    this.ctx.lineTo(x, Math.min(MAP_HEIGHT, this.camera.y + this.canvas.height));
                    this.ctx.stroke();
                }

                for (let y = startY; y < startY + this.canvas.height + gridSize; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(Math.max(0, this.camera.x), y);
                    this.ctx.lineTo(Math.min(MAP_WIDTH, this.camera.x + this.canvas.width), y);
                    this.ctx.stroke();
                }
            }

            drawBoundaries() {
                this.ctx.strokeStyle = '#FF003C';
                this.ctx.lineWidth = 4;
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = '#FF003C';
                this.ctx.strokeRect(0, 0, MAP_WIDTH, MAP_HEIGHT);
                this.ctx.shadowBlur = 0;
            }

            drawPlayers() {
                for (const player of this.state.players) {
                    if (!player.alive) continue;

                    const isLocal = player.id === this.state.playerId;

                    // Glow
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = player.color;

                    // Body
                    this.ctx.fillStyle = player.color;
                    this.ctx.beginPath();
                    this.ctx.arc(player.x, player.y, 20, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Inner circle
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.arc(player.x, player.y, 12, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Direction indicator (gun)
                    this.ctx.fillStyle = player.color;
                    this.ctx.beginPath();
                    const gunLength = 30;
                    const gunWidth = 8;
                    this.ctx.save();
                    this.ctx.translate(player.x, player.y);
                    this.ctx.rotate(player.angle);
                    this.ctx.fillRect(15, -gunWidth / 2, gunLength, gunWidth);
                    this.ctx.restore();

                    // Name tag
                    this.ctx.shadowBlur = 0;
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '12px Rajdhani';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(player.nickname, player.x, player.y - 35);
                }
            }

            drawBullets() {
                this.ctx.globalCompositeOperation = 'lighter';

                for (const bullet of this.state.bullets) {
                    // Glow
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = '#00F0FF';

                    // Bullet
                    this.ctx.fillStyle = '#00F0FF';
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Trail
                    this.ctx.fillStyle = 'rgba(0, 240, 255, 0.5)';
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x - bullet.vx * 0.3, bullet.y - bullet.vy * 0.3, bullet.radius * 0.6, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                this.ctx.shadowBlur = 0;
                this.ctx.globalCompositeOperation = 'source-over';
            }

            drawEnemies() {
                for (const enemy of this.state.enemies) {
                    // Glow
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = enemy.color;

                    this.ctx.fillStyle = enemy.color;

                    if (enemy.type === 'tank') {
                        // Hexagon
                        this.ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI * 2) / 6;
                            const x = enemy.x + Math.cos(angle) * enemy.radius;
                            const y = enemy.y + Math.sin(angle) * enemy.radius;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                    } else if (enemy.type === 'fast') {
                        // Triangle
                        this.ctx.beginPath();
                        this.ctx.moveTo(enemy.x + Math.cos(enemy.angle) * enemy.radius, enemy.y + Math.sin(enemy.angle) * enemy.radius);
                        this.ctx.lineTo(enemy.x + Math.cos(enemy.angle + 2.5) * enemy.radius, enemy.y + Math.sin(enemy.angle + 2.5) * enemy.radius);
                        this.ctx.lineTo(enemy.x + Math.cos(enemy.angle - 2.5) * enemy.radius, enemy.y + Math.sin(enemy.angle - 2.5) * enemy.radius);
                        this.ctx.closePath();
                        this.ctx.fill();
                    } else {
                        // Circle
                        this.ctx.beginPath();
                        this.ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                        this.ctx.fill();
                    }

                    // Health bar for damaged enemies
                    if (enemy.health < enemy.maxHealth) {
                        const barWidth = enemy.radius * 2;
                        const barHeight = 4;
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        this.ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.radius - 10, barWidth, barHeight);
                        this.ctx.fillStyle = enemy.color;
                        this.ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.radius - 10, barWidth * (enemy.health / enemy.maxHealth), barHeight);
                    }

                    this.ctx.shadowBlur = 0;
                }
            }
        }

        // Game constants (must match server)
        const MAX_HEALTH = 100;
        const MAP_WIDTH = 1600;
        const MAP_HEIGHT = 1200;

        // Initialize game
        const game = new GameClient();
    </script>
</body>
</html>
